\documentclass[twocolumn,10pt]{scrartcl}

% packages
\usepackage{xltxtra}
\usepackage{polyglossia}
\usepackage[left=2cm,right=2cm,top=3cm,bottom=3cm]{geometry}
\usepackage{hyperref}
\usepackage{natbib}
% fonts general
%\setmainfont[Mapping=tex-text,Scale=1.0]{FreeSerif}
%\setsansfont[Mapping=tex-text,Scale=1.0]{FreeSans}
%\setmonofont{FreeMono}


\begin{document}

\title{BEASTling: a software tool for computational linguistic phylogenetics using BEAST 2}
\author{Luke Maurits, Robert Forkel}
\maketitle

\abstract{\textbf{Abstract:} We present a new open source software tool called BEASTling, designed to simplify the preparation of Bayesian phylogenetic analyses of linguistic data using the BEAST 2 platform.  BEASTling transforms comparatively short and human-readable configuration files into the XML files used by BEAST 2 to specify analyses.  By taking advantage of Creative Commons-licensed data from the Glottolog project, BEASTling facilitates automatic and intelligent handling of datasets, allowing the user to conveniently filter datasets by recognised language families, or to impose monophyly constraints so that inferred language trees are backward compatible with Glottolog classifications.  BEASTling is intended to make the power of Bayesian analysis more accessible to historical linguists without strong programming backgrounds, in the hopes of encouraging communication and collaboration between those developing computational models of language evolution (who are typically not linguists) and relevant domain experts.}

\section{Introduction}

Recent years have seen an increased interest in the use of computational and especially Bayesian methods for inferring phylogenetic trees of languages within an explicit, model-based framework \citep[e.g.,][]{Gray2003,Gray2009,Bouckaert2012} (\textbf{LM: feel free to suggest further citations here, especially non-Auckland ones.}).  Given the recency of this trend, there is currently a lack of language-specific software for these sorts of analyses.  Thus, published analyses to date have all relied on software developed for biological phylogenetics, such as BayesTraits, BEAST\cite{Drummond2012,Bouckaert2014} or MrBayes\cite{Huelsenbeck2001, Ronquist2003}.

Amongst these existing pieces of software, BEAST (in its modern 2.x form) is unique in that it was deliberately designed from the ground up to support user extensibility.  It is possible for users to write packages which extend the phylogenetic modelling capabilities of BEAST, by e.g. specifying new tree priors or new substitution models.  This makes BEAST an appealing platform for the burgeoning field of computational linguistic phylogenetics, as those working in the field have the ability to develop language-specific models and readily share them amongst themselves, in a process requiring no input from the BEAST development team.

One impediment to the widespread adoption of BEAST by the linguistics community is the difficulty of configuring analyses.  BEAST analyses are specified in XML files which contain the input data as well as all the details of the modelling, including things such as tree constraints, substitution models, clock and rate variation,  and prior distributions for trees and all parameters, as well as the various mechanisms for drawing MCMC proposals, details on which parameters to log, etc.

The recommended way for BEAST users to generate these XML analysis specifications is using the BEAUti program distributed with BEAST.  BEAUti is a GUI tool intended to provide a user friendly means of generating XML files for BEAST.  However, BEAUti is not an especially appealing tool for linguists.  Because BEAST is primarily a tool for biological phylogenetics, BEAUti makes extensive use of biological terminology which may be unfamiliar or confusing to linguists; in particular, words like \emph{alignment} or \emph{morphology} have different meanings in the two fields.  BEAUti expects to load data in the NEXUS file format, which is commonly used in biology but not in linguistics.  The workflow in BEAUti is best suited to scenarios where the same modelling assumptions apply to a very large number of datapoints of the same kind, such as individual nucleotides in a DNA or RNA sequence.  This is very different to the typical situation in linguistics, where each feature in a dataset may warrant its own unique treatment, which the BEAUti workflow is not well suited to.  Further, many desirable tasks for setting up a linguistic analysis are tedious and error-prone procedures in BEAUti.  For example, placing monophyly constraints so that all of the languages in a well supported and recognised language family are forced to remain in a single clade requires using the mouse to find and individually click on the name of every language in the family, choosing them out of a scrolling list of all languages in the analysis.  The same task is required for adding calibration dates to the ancestor of sets of families.  This is impractical for large and detailed analyses.

Among experienced BEAST users in the computational biology field, it is a common practice to write small scripts which parse dta files and generate XML files for complex analyses which are impractical or impossible to configure using BEAUti.  The required degree of programming ability, familiarity with XML and knowledge of BEAST internals present a high barrier of entry to interested linguists who might otherwise bring valuable experience to the field.

In addition to BEAST XML files being difficult to generate, they are also not very human-readable.  Many of the XML elements have names or attributes which are derived from the names of objects, methods or parameters in the BEAST source code, which most users are not familiar with.  The XML files for complicated analyses with large datasets can easily be thousands of lines long.  Reading an unfamiliar XML file - such as one provided by a collaborator, one a user generated themselves a year ago for a old project, or one associated with a manuscript undergoing peer review - and understanding all of the details of the analysis is a difficult and time-consuming process, especially for inexperienced users.  Conceptually simple changes to an analysis, such as removing a single language or linguistic feature from an analysis, require deleting or carefully changing multiple lines of the XML file, in several different locations.  While publishing a BEAST XML file in principle provides a level of methodological transparency which is commendable and rarely achieved in scientific research, the practical difficulty of working with the files might sometimes discourage close scrutiny, error checking, or making small changes to investigate the effect of different assumptions.

In this paper we introduce a new software package named \emph{BEASTling} which aims to alleviate these problems.  The goal of BEASTling is to make the specification of BEAST analyses for linguistic phylogenetics simple and accessible, even when the analyses are large or complicated.  By making the power of BEAST accessible to a broader range of interested researchers in linguistics, we hope to foster increased collaboration between experts in linguistics and computational evolution to develop further and faster the formal, quantitative and data-driven approach to historical linguistics.

\section{Design and Implementation}

BEASTling is a command-line program written in the Python 2 programming language, which takes the approach of transforming one kind of configuration file into another, effectively specifying an alternative configuration file format for BEAST.  In contrast to BEAST's native XML files, BEASTling configuration files are designed to be short, neat, human-readable, and intuitively editable by hand.  Analyses are specified at a high-level of abstraction, roughly corresponding to the details that a typical user might have in their head when designing an analysis, e.g. ``I'd like to infer a phylogenetic tree of the Austronesian languages, using structural data from WALS,  with the Lewis Mk substitution model, permitting rate variation but with a strict clock''.  Typical BEASTling configuration files are approximately 15-25 lines long.  An example valid configuration file is shown in Figure \ref{fig:config}.

\begin{figure}[t]
	\begin{verbatim}[admin]
basename = mk_eurasian
[MCMC]
chainlength = 50000000
[languages]
families = Indo-European, Uralic, Yukaghir
monophyletic = True
[model wals]
data = wals_data.csv
model = mk
frequencies = empirical
rate_variation = True
[calibration_dates]
Indo-European = 7800 - 9800
Uralic = 3330 - 7503\end{verbatim}
	\caption{An example BEASTling configuration file, specifying an analysis of 3 Eurasian language families, using the Lewis Mk model with empirical base frequencies and Gamma-distributed rate variation, and two calibration points.}
\label{fig:config}
\end{figure}

When a BEASTling configuration file is transformed into a BEAST XML file, the text of the original BEASTling configuration is embedded at the start of the XML file in a comment block, along with the date and time the transformation was performed and the version of BEASTling which was used.  This goes a long way to making the generated XML files self-documenting.  An old, forgotten analysis file can be understood in one minute instead of one hour, and making tweaks is straightforward as the old configuration can be copied into a new file and modified.  Furthermore, BEASTling provides an option to embed copies of all referenced data files in the XML file as additional comment blocks.  The resulting XML file is then entirely self-contained, allowing researchers to distribute in one file everything require to reproduce or modify the analysis in question.

BEASTling analyses are focussed on the inference of phylogenetic trees from linguistic data.  Sampled trees are logged by default, in the standard Newick format.  Additional information can be logged if desired, including things like transition rates and substitution model parameters.  It is also possible for users to provide a known and trusted phylogenetic tree which is held fixed during the analysis, so that model parameters may be estimated conditioned on that tree.  Noteworthy modelling features supported by the current BEASTling release (1.0.1) are Gamma-distributed rate heterogeneity, Normally-distributed age priors for calibration clades, and monophyly constraints.  In addition, BEASTling can automatically handle data-preprocessing chores such as automatically filtering a dataset down to only a specified set of languages and/or features, and removing languages which have only missing data for the selected feature set, or features which have only missing data or constant values for the selected language set.

\subsection{Phylogenetic modelling}

BEASTling makes what are intended to be sensible high-level decisions about the nature of the probabilistic phylogenetic models underlying its analyses, while still providing sufficient control and flexibility that appropriate models can be specified for most investigations.

BEASTling analyses use the Yule pure birth process to define a prior distribution over phylogenetic trees.  The birthrate parameter is fixed over all locations on the tree, but the particular fixed value is inferred during the MCMC procedure.  The Yule prior is one of two tree prior families supported by BEAST, and in biological applications is typically used to constraint trees over multiple species, i.e. the branching events are interpreted as speciation.  The other supported family is the coalescent process, which is typically used for trees over populations of a single species.  Coalescent trees have a characteristic shape in which the oldest branching events are very much older than the most recent.  There is no theoretical basis for expecting the language diversification process, which is more often analogised to speciation than within-population variation, to yield trees with this shape, nor is there empirical evidence in any established reconstructions.  BEASTling therefore prefers the Yule prior.  The development of new tree priors specifically designed for linguistic phylogenetics is a continuing area of research, and future releases of BEASTling will include support for any suitable new tree priors implemented for BEAST.

The current BEASTling release supports only strict clock models.  If no calibration dates are provided, then the clock rate is fixed at 1.0, and the branch lengths of the tree can be interpreted as having units of ``expected number of mutations per feature''.  However, if calibration dates are provided for any clades in the tree, then the tree branch lengths are in the same units as the calibration dates, and the appropriate corresponding clock rate is inferred.  BEAST also supports several relaxed clock models\cite{Drummond2006}, and the ability to use these models is planned for a future release of BEASTling.

Although the clock in BEASTling models is strict, support is provided for variation in mutation rate across different linguistic features.  If enabled, each feature is assigned its own mutation rate whose value is inferred during the analysis.  Mutation rates are assigned a Gamma-distributed prior with a mean value of 1.0.  The mean of all mutation rates is also constrained to be 1.0, so that the resulting rates are easily interpreted as rates relative to the average rate, e.g. a feature with rate 2.4 evolves at more than twice the average speed, while a rate of 0.13 is almost ten times slower than average.  The Gamma distribution's shape parameter, which determines the amount of variation in rate, is fit to the data.  The need to support variation in mutation rate across features is very well established in linguistics.  The assumption that no such variation exists was one of the strongest and earliest criticisms of the first formulations of glottochronolgoy, and modern analyses have demonstrated the existence of considerable rate variation for both lexical\cite{Pagel2007} and structural\cite{Greenhill2010} data.

The probabilistic models which BEAST uses to compute the likelihood of data on a proposed tree are composed of two main parts, the equilibrium frequencies of the different permissible states for a given feature, and a substitution model specifying the relative rates of transition between two unequal states.  BEASTling allows users to choose from either uniform frequencies, where all values have equal equilibrium probabilities, or empirical frequencies (the default), where each value's equilibirum probability is proportional to its frequency in the dataset.

A number of substitution models suitable for use in linguistic analyses are available for BEASTling analyses.  The Lewis Mk model\cite{Lewis2001} is a generalised Jukes-Cantor model suitable for discrete features with an arbitrary number of permitted states.  Transitions are permitted from any state to any other, and all transitions are equally likely.  This provides a simple and sensible default model for many types of linguistic data, including structural data from sources such as WALS\cite{Dryer2013}, SAILS\cite{Muysken2014}, NTS, etc.  The Bayesian Stochastic Variable Selection (BSVS) model is a refinement of the Mk model in which some transitions may be more likely than others, and further some transitions are explicitly disallowed.  Precisely which transitions are disallowed is inferred during the MCMC analysis.  This model permits searching for directional preferences in the evolution of linguistic features.  The binary Covarion model\cite{Penny2001} is defined for datasets where each feature has two permitted values, 0 and 1.  The model permits a feature to transition between latent ``fast'' and ``slow'' states, which influence the rate at which transitions between 0 and 1 are permitted (transitions in either direction are equally probable).  During the analysis, BEAST will estimate the rate at which features switch between the fast and slow states, and the difference in speed between the two states.  This model has previously been applied to binary-encoded cognate data \cite{Bouckaert2012}.

It is possible to specify multiple datasets in a single BEASTling analysis, and each dataset may be assigned a different substitution model.  This allows combining cognate data and structural data in a single analysis, with appropriate models used for each (binary Covarion and Mk or BSVS, respectively).  If the languages present in multiple datasets do not match exactly, BEASTling can produce analyses using either the intersection or the union of the languages involved.  If the union is specified, languages will be treated as having missing data for all features defined in datasets from which the language is absent.

\subsection{Data formats}

BEASTling accepts linguistic data in comma separated value (CSV) file formats, which represent a ``lowest common denominator'' of formats, as opposed to specialist formats like NEXUS.  Two CSV formats are supported.  One is a simple ``native'' format designed for BEASTling, in which each row corresponds to one language, and contains the datapoints for every linguistic feature in the dataset (each column corresponds to one feature).  The other is the Cross-Linguistic Data Format defined by the Cross-Linguistic Linked Data project.  This makes it extremely easy to specify analyses using data from existing databases which use the CLDF format, such as WALS and SAILS.

BEASTling aims to provide flexibility in the encoding of data, to minimise the amount of work required to use existing data files.  As long as the data file conforms to one of the two supported CSV file formats, names for languages and features can be arbitrary strings (though each language and feature must have a unique name).  Feature values similarly can be arbitrary strings, with distinct strings being treated as distinct values.  Thus, BEASTling will readily accept data files where different feature values are coded numerically (0, 1, 2,\ldots or 1, 2, 3,\ldots), alphabetically (A, B, C, \ldots) or in any consistent freely written form (SOV,SVO,VSO,VOS,OVS,OSV for word order, for example).  If the binary Covarion substitution model is selected, data is automatically recoded into the required binary format.  For example, the word order feature given previously would be replaced by six features with values of 0 or 1.  This approach permits BEASTling to share a single mutation rate across the newly created features, and also means one data file can be used for binary or non-binary substitution models, rather than the user being forced to maintain two copies of the same data for use with different models.  Missing data points are represented by question marks.

\subsection{Glottolog integration}

BEASTling features integration with the Glottolog project (\texttt{http://www.glottolog.org}), which ``aims to provide a comprehensive list of languoids (families, languages, dialects)''.  The 7,746 languages in Glottolog are classified in a principled manner into a collection of phylogenetic trees comprising some 243 families with more than one member.  All clades in the Glottolog classification are provided with names, e.g. Standard English belongs to the Macro-English clade, which is a subclade of Mercian, which is a subclade of Anglian, and so on, up through West Germanic, Northwest Germanic and Germanic to Indo-European.  Because the Glottolog classification is made available under a Creative Commons Attribution-ShareAlike 3.0 license, it is possible to include a machine-readable copy of the classification in BEASTling.  If users ensure that languages in their datafiles are referred to either by their three letter ISO-639-3 code or by the four letter and four digit ``Glottocode'' assigned by the Glottolog project, then BEASTling is aware of the Glottolog classification of the languages in the dataset, and this facilitates several useful features.

Most importantly BEASTling is able to impose monophyly constraints on its analyses which enforce consistency with the Glottolog classification.  This means that, for example, in a BEASTling analysis involving the Indo-European languages, trees in which the Germanic, Romance, Slavic langauges etc. are not appropriately organised into distinct clades will be assigned a prior probability of zero.  This ensures that whatever posterior results are produced are guaranteed to be consistent with a widely recognised and respected pre-existing expert classification.

BEASTling's Glottolog integration also makes it very convenient to add important details to configurations.  Any clade in the Glottolog classification can be referred to by name for the purposes of imposing calibration dates or selecting subsets of data files.  This makes it quick and convenient to add important pre-existing linguistic knowledge to analyses.  For example, BEASTling recognises ``Imperial Latin'' as a particular node within the Indo-European clade, and we can refer to it by name to use the known age of the Roman empire to provide a calibration date range.

Glottolog clade names can also be used to specify a subset of languages in a dataset to use for an analysis, enabling the user to easily extract, say, only the Indo-European and Uralic languages from a global database.  This removes the need to maintain multiple copies of the same data for use with modelling different sets of language families.

These features demonstrate the importance and the power of making generally useful linguistic data available in machine-readable formats under permissive copyright licenses and of referring to languages using standardised, unique identifiers.

\subsection{Advanced features}

In addition to functioning as a command-line program for transforming BEASTling configuration files into BEAST analysis specifications, BEASTling can also be used as a library from within Python scripts.  When used in this fashion, it is possible to generate BEAST XML files without first creating a BEASTling configuration file.  Instead, the high-level analysis parameters are specified as attributes of a Python object.  This is convenient for programmatically generating large numbers of BEAST XML files in which either the same model specification is used for several different datasets, or a range of slightly different model specifications are used for the one dataset.  This is particularly useful for simulation studies.

Similar power for quickly generating a large number of BEAST XML files can be achieved using features of Unix shells, such as \texttt{bash}.  BEASTling can read model specification details from a BEASTling configuration file as per normal, but read the linguistic data from \texttt{stdin}.  In this way, a shell \texttt{for} loop can be used to feed several data files to separate invocations of the \texttt{beastling} command which all reference the same configuration file.

\section{Example analyses}

To illustrate the sorts of analyses BEASTling is designed to facilitate, we present the results of two example analyses.  Our intent is to demonstrate the various abilities of the software, and these analyses should not be construed as serious attempts at historical linguistic scholarship.

(\textbf{LM: Do people think I should include the BEASTling configuration files for the example analyses in the paper as Figures, like Figure 1, or just put them in supplementary material?})

\subsection{Estimating Indo-European family tree from cognate data}

Our first example is an inference of a phylogenetic tree for the Indo-European language family, using cognate data and the binary Covarion model.  The dataset is \textbf{(fix: Mattis' benchmark IE data)}, a comparatively small set which contains 19 languages and 110 features, each of which correspond to a word meaning.  The datapoints are cognate class assignments, coded as integers.  That is, two languages have the same integer for a given meaning if their words for that meaning are cognate.  Six meanings in the dataset are automatically removed by BEASTling because they are constant for the 19 languages included.  Because the binary Covarion model was specified, BEASTling automatically reformats the cognate data for 104 remaining meanings into binary form.  Because the languages in the datafile are identified by English names (``Dutch'', ``Swedish'', ``English'', etc.) and not ISO codes or Glottocodes, BEASTling cannot automatically impose monophyly constraints, so this feature is disabled.  No calibration dates are provided, and rate variation is enabled.

The maximum clade credibility tree produced by this analysis is shown in Figure \ref{fig:ie}.  Note that despite the lack of monophyly constraints, the tree is in fairly good agreement with conventional wisdom on Indo-European history.  The Slavic, Germanic and Romance sub-families are all correctly positioned in their own clades with high posterior support.  The order in which Armenian, Greek and Hindi branch is not correct, but this can be attributed to the small number of languages in the dataset.

\begin{figure}[t]
	\includegraphics[scale=0.6]{examples/indoeuropean/mcct.pdf}
	\caption{Maximum clade credibility tree for the Indo-European languages in our first example analysis.  The values at branches represent posterior probabilities for the corresponding clades. (\textbf{LM: The tree is of course ultrametric, even though it doesn't look it here.  I'm using a new (to me) tree drawing library and still need to learn how to tweak things.)}}
\label{fig:ie}
\end{figure}
In addition to a posterior sample of trees, the analysis logs posterior distributions over the relative mutation rate parameters for the 110 features.  A modest amount of rate variation is inferred, with the fastest feature has a rate a little more than 5 times faster than the slowest feature.  Table \ref{tab:ie} shows the features with the ten highest and ten lowest rates.  Notice that 4 of the 10 slowest features are body parts.

(\textbf{LM: A few notes on this: first, this is quite a bit less variation in rate than observed in Pagel et al 2007 for IE data.  I suppose this may come down to the small amount of data being used.  Secondly, do the particular meaning slots which come out as being slow/fast seem intuitively plausible to linguists?  Thirdly, I will likely redo this analysis very soon: the dataset encodes known borrowings as negative integers (e.g. a language with value -4 has borrowed a word from cognate set 4).  BEASTling doesn't known this convention and treats 4 and -4 as distinct values.  I may just replace all negative numbers with question marks and do it again.  I do  not expect massive changes, but if Aermenian/Greek/Hindi got shuffled it would be nice.})
\begin{table}[t]
	\begin{center}
	\begin{tabular}{|l|c||l|c|}
		\hline
		\multicolumn{2}{|c||}{Slowest} & \multicolumn{2}{|c|}{Fastest} \\ \hline
		Feature & Rate  & Feature & Rate \\ \hline
		star & 0.390 & tail & 2.068 \\
		tooth & 0.401 & to know & 1.933 \\
		I & 0.408 & bark & 1.873 \\
		tongue & 0.409 & that & 0.816 \\
		sun & 0.410 & belly & 1.796 \\
		full & 0.431 & small & 1.795 \\
		name & 0.432 & big & 1.756 \\
		eye & 0.437 & short & 1.704 \\
		ear & 0.439 & breast & 1.691 \\
		person & 0.543894 & to eat & 1.687 \\ \hline
	\end{tabular}
	\end{center}
	\caption{Relative mutation rates of the ten slowest and fastest changing meaning classes in our example analysis of Indo-European cognate data.}
\label{tab:ie}
\end{table}

\subsection{Fitting mutation rates to WALS features using a fixed Austronesian tree}

Our second example is an illustration of BEASTling's ability to accept a user-specified starting tree, and to sample only model parameters during the MCMC run, leaving tree topology and branch lengths fixed.  We use the maximum clade credibility tree from a 2009 Bayesian investigation of Austronesian language family phylogeny by Gray et. al.\cite{Gray2009}.  The tree is pruned to include only those Austronesian languages which are present in the WALS database, and the WALS data is applied to the leaves.  A Lewis Mk model is specified for the data, with rate variation enabled.  The inferred rates are the subject of interest.  Since the tree is fixed to a known value, BEASTling automatically disables tree logging.

The inferred rates show a wider variation than for the Indo-European example.  The fastest changing feature has a rate just over 15 times higher than the slowest changing feature.  Table \ref{tab:austro} shows the 10 slowest and fastest changing features.  9 of the 10 slowest are categorised by WALS as word order features, consistent with conventional wisdom that these are some of the most stable structural features.  The 10 fastest changing features come from a wider range of categories, but the most common are nominal categories and phonology (particularly features related to stress and rhythm).

(\textbf{LM: Question for Austronesianists: is the phonological component of the fastest rates perhaps something that would be an expected consequence of some high-level feature of the family?  It's also possible that these results are driven to some extent by missing data.  I might redo this will something like all features with less than 50\% data removed.  I may even add a feature to BEASTling to automate this kind of trimming.})

\begin{table*}[ht]
	\begin{tabular}{|l|c|}
		\hline
		Feature & Rate  \\ \hline
		\multicolumn{2}{|c|}{Slowest} \\ \hline
		Order of Object and Verb & 0.116 \\
		Order of Adposition and Noun Phrase & 0.142 \\
		Relationship between the Order of Object and Verb and the Order of Adposition and Noun Phrase & 0.191 \\
		Relationship between the Order of Object and Verb and the Order of Relative Clause and Noun & 0.197 \\
		Order of Genitive and Noun & 0.213 \\
		Position of Pronominal Possessive Affixes & 0.300 \\
		Order of Subject and Verb & 0.328 \\
		Order of Negative Morpheme and Verb & 0.395 \\
		Relationship between the Order of Object and Verb and the Order of Adjective and Noun &  0.401 \\
Order of Subject, Object and Verb & 0.436 \\
		Order of Numeral and Noun & 0.438 \\
		Order of Adjective and Noun & 0.484 \\ \hline
		\multicolumn{2}{|c|}{Fastest} \\ \hline
		Order of Degree Word and Adjective & 1.301 \\
		Overlap between Situational and Epistemic Modal Marking & 1.302 \\
		Distributive Numerals & 1.318 \\
		The Prohibitive & 1.320 \\
		Obligatory Double Negation in SVO languages & 1.340 \\
		Comitatives and Instrumentals & 1.471 \\
		Weight-Sensitive Stress & 1.473 \\
		Definite Articles & 1.474 \\
		The Position of Negative Morphemes in SOV Languages & 1.528 \\
		Ordinal Numerals & 1.561 \\
		Rhythm Types & 1.598 \\
	   	Ditransitive Constructions: The Verb `Give' & 1.618 \\
		Fixed Stress Locations & 1.770 \\ \hline
	\end{tabular}
	\caption{Relative mutation rates of the ten slowest and fastest changing features in our example analysis of Austronesian structural data.}
\label{tab:austro}
\end{table*}

\section{Availability and Future Directions}

BEASTling is an open source project and full source code is available in a source repository hosted by GitHub at \texttt{https://github.com/lmaurits/BEASTling}, under the terms of a 2-clause BSD license.  BEASTling is also hosted at the Python Package Index (PyPI) and thus may be easily installed using standard Python packaging tools such as \texttt{easy\char`_install} or \texttt{pip}.  Searchable documentation is hosted by Read The Docs at \texttt{https://beastling.readthedocs.org}.

The author intends to continually update BEASTling to support any new linguistically-relevant BEAST packages which may appear, and to keep model specifications in line with emerging consensuses on best practice.

\section{Acknowledgemnts}

Thanks to Michael Dunn and Robert Forkel for testing early versions of BEASTling, and submitting bug reports and feature requests; to Gereon Kaiping for contributing bug fixes and some feature implementations; to Simon Greenhill for providing the Austronesian reference tree and a mapping from language names to ISO codes; and special thanks to Remco Bouckaert for BEAST advice and insight.

\bibliography{bibliography.bib}
\bibliographystyle{plain}

%\printbibliography
\end{document}
